import * as fs from "node:fs/promises";
import * as path from "node:path";
import { exec } from "node:child_process";

export interface CommandResult {
  ok: boolean;
  output: string;
}

export interface InstallResult {
  step: string;
  ok: boolean;
  output: string;
}

export interface ScaffoldResult {
  root: string;
  created: string[];
  installs: InstallResult[];
}

function quoteArg(arg: string): string {
  if (/^[a-zA-Z0-9._:/\\-]+$/.test(arg)) {
    return arg;
  }

  return `"${arg.replace(/"/g, "\\\"")}"`;
}

function run(command: string, args: string[], cwd: string, timeoutMs: number): Promise<CommandResult> {
  const commandLine = `${command} ${args.map(quoteArg).join(" ")}`.trim();
  return new Promise((resolve) => {
    exec(commandLine, { cwd, timeout: timeoutMs }, (error, stdout, stderr) => {
      resolve({
        ok: !error,
        output: `${stdout ?? ""}${stderr ?? ""}`.trim()
      });
    });
  });
}

async function runWithRetry(
  command: string,
  args: string[],
  cwd: string,
  timeoutMs: number,
  retries: number
): Promise<CommandResult> {
  let last: CommandResult = { ok: false, output: "No attempts executed." };
  for (let attempt = 1; attempt <= retries; attempt += 1) {
    last = await run(command, args, cwd, timeoutMs);
    if (last.ok) {
      return last;
    }
  }

  return last;
}

async function writeFileIfMissing(filePath: string, content: string, created: string[]): Promise<void> {
  try {
    await fs.access(filePath);
  } catch {
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, content, "utf8");
    created.push(filePath);
  }
}

export async function scaffoldReactSupabaseProject(workspaceRoot: string, projectName: string): Promise<ScaffoldResult> {
  const projectRoot = path.join(workspaceRoot, projectName);
  const frontendRoot = path.join(projectRoot, "frontend");
  const supabaseRoot = path.join(projectRoot, "supabase");
  const functionsRoot = path.join(supabaseRoot, "functions");
  const apiRoot = path.join(functionsRoot, "api");
  const created: string[] = [];

  await fs.mkdir(frontendRoot, { recursive: true });
  await fs.mkdir(apiRoot, { recursive: true });

  await writeFileIfMissing(
    path.join(projectRoot, "README.md"),
    `# ${projectName}\n\nGenerated by Manifold Phase 2 local scaffolding.\n\n## Architecture\n\n- **Frontend**: React + Vite (deployed to Vercel)\n- **Backend**: Supabase Edge Functions (TypeScript/Deno)\n`,
    created
  );

  await writeFileIfMissing(
    path.join(projectRoot, ".gitignore"),
    `# Dependencies
node_modules/

# Build outputs
dist/
build/

# Environment files
.env
.env.local
.env.*.local

# Manifold state (contains tokens)
.manifold.json
.manifold-logs/

# IDE
.vscode/
.idea/
*.swp
*.swo
*.iml

# OS
.DS_Store
Thumbs.db

# Supabase
.branches/
`,
    created
  );

  await writeFileIfMissing(
    path.join(projectRoot, "vercel.json"),
    `{
  "version": 2,
  "buildCommand": "cd frontend && npm run build",
  "outputDirectory": "frontend/dist"
}
`,
    created
  );

  await writeFileIfMissing(
    path.join(supabaseRoot, "config.toml"),
    `[api]
enabled = true
port = 54321
schemas = ["public", "storage", "graphql_public"]
extra_search_path = ["public", "extensions"]
max_rows = 1000

[db]
port = 54322
shadow_port = 54320
major_version = 15

[studio]
enabled = true
port = 54323

[auth]
enabled = true
site_url = "http://localhost:3000"
additional_redirect_urls = ["http://localhost:5173"]

[functions.api]
verify_jwt = false
`,
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, ".gitignore"),
    `node_modules/
dist/
.env
.env.local
`,
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, "package.json"),
    JSON.stringify(
      {
        name: `${projectName}-frontend`,
        private: true,
        version: "0.1.0",
        type: "module",
        scripts: {
          dev: "vite",
          build: "vite build",
          preview: "vite preview"
        },
        dependencies: {
          react: "^18.3.1",
          "react-dom": "^18.3.1"
        },
        devDependencies: {
          "@types/react": "^18.3.8",
          "@types/react-dom": "^18.3.0",
          typescript: "^5.8.3",
          vite: "^6.2.0"
        }
      },
      null,
      2
    ) + "\n",
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, "index.html"),
    `<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>${projectName}</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n`,
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, "tsconfig.json"),
    `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "lib": ["ES2022", "DOM"],
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": ["src"]
}
`,
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, "src", "api.ts"),
    `export async function getHealth(): Promise<string> {
  const supabaseUrl = (import.meta as any).env?.VITE_SUPABASE_URL;
  const supabasePublishableKey = (import.meta as any).env?.VITE_SUPABASE_PUBLISHABLE_KEY;
  if (!supabaseUrl) {
    throw new Error("VITE_SUPABASE_URL is not set");
  }
  if (!supabasePublishableKey) {
    throw new Error("VITE_SUPABASE_PUBLISHABLE_KEY is not set");
  }
  const response = await fetch(supabaseUrl + "/functions/v1/api/health", {
    headers: {
      apikey: supabasePublishableKey,
      Authorization: "Bearer " + supabasePublishableKey
    }
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error("Health check failed: " + response.status + " " + errorText);
  }
  const data = await response.json();
  if (data && typeof data.status === "string") {
    return data.status;
  }
  return "ok";
}
`,
    created
  );

  await writeFileIfMissing(
    path.join(frontendRoot, "src", "main.tsx"),
    `import React from "react";
import { createRoot } from "react-dom/client";
import { getHealth } from "./api";

function App() {
  const [status, setStatus] = React.useState("loading");

  React.useEffect(() => {
    let active = true;
    getHealth()
      .then((value) => {
        if (active) {
          setStatus(value);
        }
      })
      .catch(() => {
        if (active) {
          setStatus("error");
        }
      });

    return () => {
      active = false;
    };
  }, []);

  return (
    <div style={{ fontFamily: "system-ui, sans-serif", padding: "2rem" }}>
      <h1>${projectName} frontend is ready.</h1>
      <p>Backend health: {status}</p>
    </div>
  );
}

createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`,
    created
  );

  await writeFileIfMissing(
    path.join(apiRoot, "index.ts"),
    `import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

serve(async (req: Request) => {
  const url = new URL(req.url);
  const requestPath = url.pathname;

  // CORS headers
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  };

  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  // Health endpoint
  const isHealthRoute =
    requestPath === "/health" ||
    requestPath === "/api/health" ||
    requestPath.endsWith("/functions/v1/api/health");

  if (isHealthRoute) {
    return new Response(
      JSON.stringify({ status: "ok" }),
      { 
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200
      }
    );
  }

  // Default 404
  return new Response(
    JSON.stringify({ error: "Not found" }),
    { 
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 404
    }
  );
});
`,
    created
  );

  await writeFileIfMissing(
    path.join(apiRoot, "deno.json"),
    `{
  "tasks": {
    "serve": "deno run --allow-net --allow-env index.ts"
  },
  "imports": {}
}
`,
    created
  );


  const installs: InstallResult[] = [];

  const npmInstall = await runWithRetry("npm", ["install"], frontendRoot, 180_000, 2);
  installs.push({
    step: "frontend npm install",
    ok: npmInstall.ok,
    output: npmInstall.output
  });

  return {
    root: projectRoot,
    created,
    installs
  };
}
